---
title: "Builder Guide"
description: "Strategy development and marketplace listing guide for strategy creators"
---

## Overview

The ClyptQ Builder Guide is for **strategy developers**. This guide covers everything from strategy development to marketplace listing, showing how to **generate revenue** in the Trading Commerce ecosystem.

## Why Build on ClyptQ?

**Immediate Access to Production Infrastructure**:
- Data (crypto, stocks, macro, on-chain)
- Execution engine (backtest, paper, live)
- Monitoring & alerts
- Risk management tools

**Reliability Guarantee**:
- Backtest = Live (same code)
- Reproducible results
- Automatic verification

**Monetization**:
- Marketplace listing
- Performance-based fees
- Subscription model

## Development Workflow

```
1. Strategy Development
   ↓ Compose strategy with ComputeGraph

2. Backtest (INSTANT)
   ↓ Verify strategy logic

3. Backtest (LATENT)
   ↓ Realistic simulation

4. Paper Trading
   ↓ Test with real-time data

5. Live Trading (Small)
   ↓ Validate in production with small capital

6. Marketplace Listing
   ↓ Share strategy and monetize
```

## Step 1: Strategy Development

**Compose Strategy with Operators**:

```python
from clyptq.system.graph import ComputeGraph, Input
from clyptq.operators.signal import MomentumAlpha
from clyptq.operators.indicator import SMA
from clyptq.operators.filter import LiquidityFilter

def create_strategy():
    graph = ComputeGraph()

    # Data
    close = graph.add_node("close", FieldExtractor("close"))
    volume = graph.add_node("volume", FieldExtractor("volume"))

    # Indicators
    sma_fast = graph.add_node("sma_fast",
        SMA(Input("close", lookback=10), span=10)
    )
    sma_slow = graph.add_node("sma_slow",
        SMA(Input("close", lookback=50), span=50)
    )

    # Signal
    signal = graph.add_node("signal",
        CrossoverAlpha(
            Input("sma_fast", lookback=1),
            Input("sma_slow", lookback=1)
        )
    )

    # Filter
    universe = graph.add_node("universe",
        LiquidityFilter(Input("volume", lookback=20), min_volume=1_000_000)
    )

    # Apply filter
    filtered_signal = graph.add_node("filtered_signal",
        Multiply(Input("signal", lookback=1), Input("universe", lookback=1))
    )

    return graph
```

**Create StrategySpec**:

```python
from clyptq.apps.trading.spec import StrategySpec

strategy_spec = StrategySpec(
    graph=create_strategy(),
    signal_node="filtered_signal",  # Alpha output
    output_nodes=["filtered_signal", "sma_fast", "sma_slow"]
)
```

## Step 2: Backtest (INSTANT)

**Verify Strategy Logic** (perfect execution):

```python
from clyptq.apps.trading.spec import TradingSpec
from clyptq.apps.trading import TradingDriver

spec = TradingSpec(
    strategy=strategy_spec,

    data=TradingDataSpec(
        observations=[
            OHLCVSpec(
                identifier="ohlcv_1m",
                venue="binance",
                market_type="futures",
                timeframe="1m",
                fields=["close", "volume"]
            )
        ]
    ),

    execution=TradingExecutionSpec(
        mode="backtest",
        venue="binance",
        market_type="futures",
        latency_mode="INSTANT",  # No slippage
        clock_freq="1m"
    ),

    accounts=[
        AccountSpec(
            type="futures",
            venue="binance",
            initial_balance={"USDT": 10000.0},
            margin_type="CROSS",
            default_leverage=3.0
        )
    ],

    symbol_source_map=SymbolSourceMap(
        mappings={
            "BTC/USDT:USDT": ["ohlcv_1m"],
            "ETH/USDT:USDT": ["ohlcv_1m"]
        }
    )
)

# Run
driver = TradingDriver.from_spec(spec)
driver.load_data(
    items=["BTC/USDT:USDT", "ETH/USDT:USDT"],
    start=datetime(2024, 1, 1),
    end=datetime(2024, 12, 31)
)

results = driver.run()

# Analyze
print(f"Total Return: {results.total_return:.2%}")
print(f"Sharpe Ratio: {results.sharpe_ratio:.2f}")
print(f"Max Drawdown: {results.max_drawdown:.2%}")
print(f"Win Rate: {results.win_rate:.2%}")
```

**Checklist**:
- [ ] Does strategy generate signals?
- [ ] Is return positive?
- [ ] Sharpe ratio > 1.0?
- [ ] Max drawdown < 30%?

## Step 3: Backtest (LATENT)

**Realistic Simulation** (with slippage and fees):

```python
spec = TradingSpec(
    strategy=strategy_spec,
    data=data_spec,

    execution=TradingExecutionSpec(
        mode="backtest",
        venue="binance",
        market_type="futures",
        latency_mode="LATENT",      # Orderbook matching
        fill_model="aggressive",    # Taker orders
        clock_freq="1m"
    ),

    accounts=accounts_spec,
    symbol_source_map=symbol_map
)

driver = TradingDriver.from_spec(spec)
driver.load_data(...)
results = driver.run()

# Compare with INSTANT
print(f"INSTANT Return: {instant_return:.2%}")
print(f"LATENT Return: {latent_return:.2%}")
print(f"Impact: {(instant_return - latent_return):.2%}")
```

**Checklist**:
- [ ] Return degradation < 20% vs INSTANT?
- [ ] Still Sharpe > 1.0?
- [ ] Profitable after costs?

## Step 4: Paper Trading

**Simulated Trading with Real-time Data**:

```python
spec = TradingSpec(
    strategy=strategy_spec,
    data=data_spec,

    execution=TradingExecutionSpec(
        mode="paper",
        venue="binance",
        market_type="futures",
        clock_freq="1m"
    ),

    accounts=accounts_spec,
    symbol_source_map=symbol_map
)

driver = TradingDriver.from_spec(spec)
driver.load_data(
    items=["BTC/USDT:USDT"],
    mode="live",
    warmup_ticks=100
)

# Run continuously
for result in driver.run():
    print(f"{result.timestamp}: PnL={result.pnl:.2f}")
```

**Monitoring**:
- Real-time performance tracking
- Signal generation frequency
- Order execution timing
- Slippage analysis

**Duration**: Minimum 2-4 weeks execution

## Step 5: Live Trading (Small)

**Small Capital Production Validation**:

```python
spec = TradingSpec(
    strategy=strategy_spec,
    data=data_spec,

    execution=TradingExecutionSpec(
        mode="live",
        venue="binance",
        market_type="futures",
        api_key=os.getenv("BINANCE_API_KEY"),
        api_secret=os.getenv("BINANCE_API_SECRET"),

        # Conservative risk limits
        max_position_pct=0.1,   # Max 10%
        max_leverage=2.0,       # Max 2x
        max_drawdown=0.10,      # Stop at 10% loss

        clock_freq="1m"
    ),

    accounts=[
        AccountSpec(
            type="futures",
            venue="binance",
            # Use actual account balance
            margin_type="CROSS",
            default_leverage=2.0
        )
    ],

    symbol_source_map=symbol_map
)

driver = TradingDriver.from_spec(spec)
driver.load_data(
    items=["BTC/USDT:USDT"],
    mode="live",
    warmup_ticks=100
)

# Run with monitoring
for result in driver.run():
    # Log to monitoring system
    monitor.log_performance(result)

    # Alert on anomalies
    if result.drawdown > 0.05:
        alert.send("Drawdown > 5%")
```

**Safety Checklist**:
- [ ] Start small (1-5% of total capital)
- [ ] Conservative risk parameters
- [ ] Real-time monitoring configured
- [ ] Emergency stop mechanism ready

**Duration**: Minimum 1-2 months execution

## Step 6: Marketplace Listing

**Strategy Packaging**:

```python
from clyptq.marketplace import StrategyListing

listing = StrategyListing(
    # Metadata
    name="Momentum Crossover Pro",
    description="SMA crossover with liquidity filter",
    version="1.0.0",
    author="your_username",

    # Spec
    spec=spec,

    # Performance (verified)
    backtest_results={
        "total_return": 0.45,
        "sharpe_ratio": 1.8,
        "max_drawdown": 0.18,
        "win_rate": 0.62
    },

    # Paper trading (verified)
    paper_results={
        "duration_days": 30,
        "total_return": 0.08,
        "sharpe_ratio": 1.5
    },

    # Live trading (verified)
    live_results={
        "duration_days": 60,
        "total_return": 0.15,
        "sharpe_ratio": 1.6,
        "verified": True  # Platform verification
    },

    # Pricing
    pricing={
        "model": "performance_fee",  # or "subscription"
        "performance_fee": 0.20,     # 20% of profits
        "min_investment": 1000.0     # $1,000 minimum
    },

    # Risk profile
    risk_profile={
        "max_leverage": 3.0,
        "max_drawdown": 0.20,
        "target_sharpe": 1.5,
        "asset_classes": ["crypto"],
        "timeframe": "1m"
    }
)

# Submit to marketplace
listing.submit()
```

**Listing Requirements**:
- [ ] 1+ year backtest results
- [ ] 2+ weeks paper trading verification
- [ ] 1+ month live trading verification (optional, recommended)
- [ ] Strategy description and logic disclosure
- [ ] Risk profile specification

## Best Practices

**1. Strategy Development**
```python
# DO
- Modularize with Operator composition
- Minimize lookback
- Apply universe filters
- Monitor performance metrics

# DON'T
- Hardcode complex logic
- Excessive lookback
- No filters for entire universe
- Generate signals without validation
```

**2. Backtesting**
```python
# DO
- Verify logic with INSTANT
- Confirm reality with LATENT
- Sufficient period (1+ year)
- Out-of-sample testing

# DON'T
- Short period (<3 months)
- Test INSTANT only
- Curve fitting
```

**3. Paper/Live**
```python
# DO
- Execute for sufficient period
- Real-time monitoring
- Conservative risk settings
- Gradual capital increase

# DON'T
- Rush to live
- Neglect monitoring
- Aggressive leverage
- Deploy full capital at once
```

**4. Risk Management**
```python
# Always configure
max_position_pct=0.2    # Max 20%
max_leverage=3.0        # Max 3x
max_drawdown=0.15       # Stop at 15% loss

# Adjust per strategy
- Conservative: pct=0.1, leverage=2.0, dd=0.10
- Moderate: pct=0.2, leverage=3.0, dd=0.15
- Aggressive: pct=0.3, leverage=5.0, dd=0.20
```

## Common Pitfalls

**Overfitting**:
```python
# Bad: Too many parameters
strategy_with_20_params()  # Likely overfitted

# Good: Simple logic
strategy_with_3_params()  # More robust
```

**Lookahead Bias**:
```python
# Bad: Use future data
close[t+1]  # Lookahead!

# Good: Historical data only
close[t-lookback:t]
```

**Survivorship Bias**:
```python
# Bad: Currently listed symbols only
symbols = get_current_listings()

# Good: Historical point-in-time basis
symbols = get_historical_listings(timestamp)
```

**Ignoring Transaction Costs**:
```python
# Bad: Test INSTANT only
latency_mode="INSTANT"

# Good: Verify with LATENT
latency_mode="LATENT"
```

## Support & Resources

**Documentation**:
- [Operator Protocol](operator-protocol.md)
- [Strategy Framework](strategy-framework.md)
- [Trading System](trading-system.md)
- [Data System](data-system.md)
- [Configuration](configuration.md)

**Community**:
- Discord: [discord.gg/clyptq](https://discord.gg/clyptq)
- GitHub: [github.com/clyptq](https://github.com/clyptq)
- Forum: [forum.clyptq.com](https://forum.clyptq.com)

**Support**:
- Email: builders@clyptq.com
- Docs: [docs.clyptq.com](https://docs.clyptq.com)

## Ecosystem Benefits

**For You (Builder)**:
- Immediate access to production infrastructure
- Backtest = Live (reliability)
- Marketplace monetization
- Community support

**For Buyers**:
- Access to verified strategies
- Transparent performance metrics
- Risk management guarantee
- Reproducible results
