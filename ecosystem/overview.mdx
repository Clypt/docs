---
title: "ClyptQ Trading Engine"
description: "Production-grade quantitative trading engine powering the Trading Commerce ecosystem"
---

## Ecosystem Vision

ClyptQ Trading Engine is a **Trading Commerce platform** that establishes trust between Buyers and Builders.

**Core Values**:
- **Transparency**: All strategy performance is verifiable and reproducible
- **Reliability**: Backtest and live trading run on the same engine for consistent results
- **Scalability**: Supports all strategies from AI-based to traditional algorithms
- **Accessibility**: Buyers evaluate strategies without code, Builders access production infrastructure instantly

## Trading Commerce Ecosystem

<Frame>
```
Builder (Strategy Creator)
    ↓ Develop & Test
    ↓ List on Marketplace

ClyptQ Trading Engine
    - Validates Performance
    - Ensures Reproducibility
    - Provides Infrastructure

    ↓ Browse & Evaluate
    ↓ Deploy with Confidence

Buyer (Capital Provider)
```
</Frame>

<CardGroup cols={2}>
  <Card title="Builder Benefits" icon="code">
    - Production infrastructure (data, execution, monitoring)
    - Identical environment from backtest to live
    - Revenue generation via marketplace
  </Card>

  <Card title="Buyer Benefits" icon="chart-line">
    - Access to verified strategies
    - Transparent performance metrics
    - Built-in risk management
  </Card>
</CardGroup>

## Architecture Overview

ClyptQ consists of **4 layers**:

<AccordionGroup>
  <Accordion title="1. System Layer - Core Execution Engine">
    - **Operator Protocol**: Standard interface for all operations
    - **TaggedArray**: 4-field data structure (value, exists, valid, updated)
    - **ComputeGraph**: Dependency-based automatic execution
    - **TradingDriver**: System-wide orchestration
  </Accordion>

  <Accordion title="2. Operator Layer - Strategy Components">
    - **Signal**: Alpha/Factor signal generation
    - **Filter**: Universe selection
    - **Indicator**: Technical indicators (40+ built-in)
    - **Metric**: Performance measurement
    - **Semantic**: LLM integration
  </Accordion>

  <Accordion title="3. Trading Layer - Execution & State Management">
    - **TradingState**: Portfolio state tracking
    - **Execution**: Order execution pipeline
    - **Intention**: Declarative order specification
    - **Spec**: Unified configuration system
  </Accordion>

  <Accordion title="4. Data Layer - Data Management">
    - **Sources**: Multi-source integration (crypto, stocks, macro)
    - **Storage**: Environment-based routing (dev/prod/kernel)
    - **Validation**: Data quality verification
  </Accordion>
</AccordionGroup>

## Key Concepts

### Operator Protocol

All operations follow the same interface:

```python
class Operator:
    def compute(self, data, timestamp, context):
        """
        Args:
            data: Dict[input_id, TaggedArray]
            timestamp: Current timestamp
            context: Execution context

        Returns:
            TaggedArray with 4 fields
        """
```

**Benefits**:
- Composable with consistent interface
- Type safety guaranteed
- Automatic dependency resolution

### TaggedArray (4-Field System)

All data is represented with 4 fields:

```python
TaggedArray:
    value: float      # Actual value
    exists: bool      # Data exists
    valid: bool       # Value validity (not NaN)
    updated: bool     # Updated at current timestamp
```

<Info>
**Benefits**:
- Explicit missing data handling
- FFill distinction (valid=True, updated=False)
- Consistent error handling
</Info>

### ComputeGraph

Strategies are represented as DAGs (Directed Acyclic Graphs) of Operators:

```python
graph = ComputeGraph()

# Nodes
close = graph.add_node("close", FieldExtractor("close"))
sma = graph.add_node("sma", SMA(Input("close", lookback=20), span=20))
signal = graph.add_node("signal", MomentumAlpha(Input("close", lookback=20)))

# Automatic dependency resolution and execution
results = graph.compute(timestamp, data, context)
```

**Benefits**:
- Automatic dependency resolution
- Parallel execution optimization
- Reproducible execution

## Execution Modes

ClyptQ supports 3 execution modes:

<Tabs>
  <Tab title="Backtest">
    **Strategy validation with historical data**

    - INSTANT mode: Perfect execution (no slippage)
    - LATENT mode: Realistic simulation (orderbook matching)
  </Tab>

  <Tab title="Paper">
    **Simulated trading with real-time data**

    - Same as live environment but no capital risk
    - Real-time strategy performance monitoring
  </Tab>

  <Tab title="Live">
    **Actual trading execution**

    - Same code as backtest
    - Built-in risk management tools
  </Tab>
</Tabs>

## Why ClyptQ?

<CardGroup cols={3}>
  <Card title="For Builders" icon="wrench">
    - **Fast Development**: Instant access to production infrastructure
    - **Reliability**: Backtest = Live (same code, same execution)
    - **Monetization**: Sell strategies via marketplace listing
  </Card>

  <Card title="For Buyers" icon="wallet">
    - **Transparency**: All performance metrics verifiable
    - **Trust**: Reproducible backtest results
    - **Safety**: Built-in risk management tools
  </Card>

  <Card title="Platform Benefits" icon="globe">
    - **Standardization**: All strategies use the same protocol
    - **Scalability**: From single strategy to portfolio
    - **Flexibility**: Supports all strategies from algorithms to AI
  </Card>
</CardGroup>

## Next Steps

<CardGroup cols={3}>
  <Card title="Builder Guide" icon="code" href="/ecosystem/builder-guide">
    Strategy Development Guide
  </Card>

  <Card title="Buyer Guide" icon="shopping-cart" href="/ecosystem/buyer-guide">
    Strategy Evaluation Guide
  </Card>

  <Card title="Operator Protocol" icon="gears" href="/engine/operator-protocol">
    Technical Details
  </Card>
</CardGroup>
