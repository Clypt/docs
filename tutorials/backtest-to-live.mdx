---
title: "Backtest to Live"
description: "Deploy the same strategy from backtest through paper to live trading"
---

## The Deployment Lifecycle

ClyptQ's code parity means the deployment lifecycle is a parameter change, not a rewrite:

```
Backtest (mode="backtest")
    │  Validate strategy logic, measure Sharpe, check costs
    ▼
Paper (mode="paper")
    │  Verify on live data with simulated fills, 2-4 weeks
    ▼
Live (mode="live")
    │  Real money, start small, scale gradually
    ▼
Scale
```

This tutorial uses the SMA crossover strategy from [Your First Strategy](/tutorials/first-strategy). The graph and operators don't change — only the `TradingExecutionSpec`.

## Phase 1: Backtest

### Run the backtest

```python
spec = TradingSpec(
    data=TradingDataSpec(
        symbol_source_map=symbol_source_map,
        observations=[OHLCVSpec(exchange="binance", market_type="futures", timeframe="1m")],
        start=datetime(2024, 1, 1, tzinfo=timezone.utc),
        end=datetime(2024, 12, 31, tzinfo=timezone.utc),
    ),
    strategy=TradingStrategySpec(graph=graph, output_nodes=["equity"]),
    execution=TradingExecutionSpec(
        mode="backtest",
        accounts=[AccountSpec(exchange="binance", market_type="futures", initial_cash=10_000)],
        execution_price_source="ohlcv",
    ),
    debug=True,
)

driver = TradingDriver.from_spec(spec)
for result in driver:
    pass

df_equity = driver.to_dataframe("equity")
```

### What to check

Before moving to paper trading, verify:

| Check | What to Look For |
|-------|-----------------|
| **Sharpe ratio** | > 1.0 after fees and funding |
| **Max drawdown** | Acceptable for your risk tolerance |
| **Fee impact** | Run with zero fees vs real fees — if gap > 50% of return, reconsider |
| **Trade frequency** | Too many trades = high fee drag |
| **Funding cost** | For long-hold strategies, check cumulative funding impact |
| **Rejection rate** | `export_results()["rejection_stats"]` — many rejections = sizing issues |

```python
# Compare with zero-cost backtest
spec_zero = TradingSpec(
    ...
    execution=TradingExecutionSpec(
        mode="backtest",
        accounts=[AccountSpec(
            exchange="binance", market_type="futures", initial_cash=10_000,
            cost_model=CostModelSpec(maker_fee=0, taker_fee=0, slippage_bps=0),
        )],
    ),
)
```

## Phase 2: Paper Trading

### Switch to paper mode

```python
spec_paper = TradingSpec(
    data=TradingDataSpec(
        symbol_source_map=symbol_source_map,
        observations=[OHLCVSpec(exchange="binance", market_type="futures", timeframe="1m")],
        # No start/end — paper mode uses live data
    ),
    strategy=TradingStrategySpec(graph=graph, output_nodes=["equity"]),
    execution=TradingExecutionSpec(
        mode="paper",         # ← Changed from "backtest"
        accounts=[AccountSpec(exchange="binance", market_type="futures", initial_cash=10_000)],
        execution_price_source="ohlcv",
    ),
)

driver = TradingDriver.from_spec(spec_paper)

# Same iterator — now running on live data with simulated fills
for result in driver:
    print(f"{result.timestamp} | equity: {result.outputs.get('equity')}")
    # Your logging, monitoring, alerting code goes here
```

### What happens internally

1. **Historical warmup**: Loads past data from Parquet to fill all RollingBuffers
2. **Clock sync**: Aligns to the next real-time bar boundary
3. **Live ticks**: Receives data via WebSocket from Binance
4. **Simulated fills**: Orders are executed by `BacktestFactory` (same as backtest)
5. **STATE updates**: Portfolio state updates with simulated positions and PnL

Paper mode is intentionally identical to backtest in execution — the only difference is the data source (live instead of historical).

### How long to paper trade

| Strategy Type | Recommended Paper Period | Why |
|--------------|-------------------------|-----|
| **Intraday** (minutes-hours) | 1-2 weeks | Need enough trades for statistical significance |
| **Daily** (hours-days) | 2-4 weeks | Capture different market conditions |
| **Swing** (days-weeks) | 4-8 weeks | Need multiple full trade cycles |

### What to verify

- **Latency**: Check `⏱️ Latency` logs — if processing exceeds clock interval, orders are delayed
- **Data gaps**: Check `warmup_info` — are there gaps in the live data feed?
- **Equity tracking**: Does paper equity roughly match what backtest predicted for similar market conditions?
- **Order execution**: Are intentions generating reasonable deltas?

## Phase 3: Live Trading (Small)

### Switch to live mode

```python
spec_live = TradingSpec(
    data=TradingDataSpec(
        symbol_source_map=symbol_source_map,
        observations=[OHLCVSpec(exchange="binance", market_type="futures", timeframe="1m")],
    ),
    strategy=TradingStrategySpec(graph=graph, output_nodes=["equity"]),
    execution=TradingExecutionSpec(
        mode="live",          # ← Changed from "paper"
        accounts=[AccountSpec(
            exchange="binance",
            market_type="futures",
            api_key="your_api_key",
            api_secret="your_api_secret",
            # Start with small capital
            # initial_cash is ignored in live mode — uses real exchange balance
        )],
    ),
)

driver = TradingDriver.from_spec(spec_live)

# Same iterator — now trading real money
for result in driver:
    print(f"{result.timestamp} | equity: {result.outputs.get('equity')}")
```

### What happens internally

1. **Balance sync**: Fetches real account balance from Binance before warmup
2. **Historical warmup**: Same as paper mode
3. **Live ticks**: WebSocket data from Binance
4. **Real orders**: `LiveFactory` sends orders to Binance via CCXT
5. **Balance re-sync**: Before each tick, checks for external changes (liquidations, manual trades, funding)
6. **Shutdown handlers**: SIGINT/SIGTERM automatically closes all positions

### Safety features

| Feature | What It Does |
|---------|-------------|
| **Emergency shutdown** | Ctrl+C or SIGTERM → close all positions immediately |
| **Balance sync** | Detects external changes (manual trades, auto-liquidation) |
| **Heartbeat** | Prevents Kernel idle timeout during long-running strategies |
| **First tick skip** | Skips execution on the first real-time tick to avoid stale signals |

### Scaling up

Start small, scale gradually:

| Phase | Capital | Duration | Purpose |
|-------|---------|----------|---------|
| **Small** | 5-10% of target | 1-2 weeks | Verify real fills match expectations |
| **Medium** | 25-50% of target | 2-4 weeks | Check for capacity constraints |
| **Full** | 100% | Ongoing | Monitor continuously |

At each phase, compare live performance to backtest expectations. Significant divergence indicates issues with execution, data, or market regime change.

## The Code Comparison

Here's what changes at each stage — and what doesn't:

```python
# Graph: IDENTICAL across all modes
graph = StatefulGraph()
graph.add_node("sma_fast", SMA(span=10), inputs=[close])
graph.add_node("sma_slow", SMA(span=50), inputs=[close])
graph.add_node("signal", CrossoverAlpha(), inputs=[...])
graph.add_node("weights", EqualWeight(), inputs=[...])
graph.add_node("equity", EquityCalculator(...))
graph.add_node("book", BookSize(...), inputs=[...])
graph.add_node("intention", FuturesTargetPositionIntention(...))

# Strategy spec: IDENTICAL
strategy = TradingStrategySpec(graph=graph, output_nodes=["equity"])

# Data spec: start/end removed for paper/live
data_backtest = TradingDataSpec(..., start=start, end=end)
data_live = TradingDataSpec(...)  # No start/end

# Execution spec: mode + credentials change
exec_backtest = TradingExecutionSpec(mode="backtest", accounts=[...])
exec_paper = TradingExecutionSpec(mode="paper", accounts=[...])
exec_live = TradingExecutionSpec(mode="live", accounts=[...with api_key...])

# Driver loop: IDENTICAL
for result in driver:
    # Same logging, monitoring, analysis code
    print(f"{result.timestamp} | equity: {result.outputs.get('equity')}")
```

## Related Pages

<CardGroup cols={2}>
  <Card title="Code Parity" icon="equals" href="/competitive/code-parity">
    Why the same code produces identical results across all modes
  </Card>
  <Card title="Backtesting Accuracy" icon="shield" href="/backtesting/overview">
    Cost models, funding rates, and liquidation in backtest
  </Card>
  <Card title="Your First Strategy" icon="graduation-cap" href="/tutorials/first-strategy">
    Build the strategy used in this tutorial
  </Card>
  <Card title="Jupyter Workflow" icon="laptop-code" href="/platform/jupyter-workflow">
    Cell-by-cell development workflow
  </Card>
</CardGroup>
